name: Manual Modrinth Publish

on:
  workflow_dispatch:
  workflow_call:
    secrets:
      MODRINTH_TOKEN:
        required: true
      MODRINTH_PROJECT_ID:
        required: true

permissions:
  contents: read

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      modrinth_project: ${{ steps.prepare.outputs.modrinth_project }}
      selected_tag: ${{ steps.prepare.outputs.selected_tag }}
      selected_is_prerelease: ${{ steps.prepare.outputs.selected_is_prerelease }}
      release_channel: ${{ steps.prepare.outputs.release_channel }}
      release_body: ${{ steps.prepare.outputs.release_body }}
      publish_matrix: ${{ steps.prepare.outputs.publish_matrix }}
      has_work: ${{ steps.prepare.outputs.has_work }}
      skipped_existing_count: ${{ steps.prepare.outputs.skipped_existing_count }}
      to_publish_count: ${{ steps.prepare.outputs.to_publish_count }}
      total_jar_count: ${{ steps.prepare.outputs.total_jar_count }}
      existing_lookup_enabled: ${{ steps.prepare.outputs.existing_lookup_enabled }}
    steps:
      - name: Validate required secrets
        env:
          MODRINTH_TOKEN: ${{ secrets.MODRINTH_TOKEN }}
          MODRINTH_PROJECT_ID: ${{ secrets.MODRINTH_PROJECT_ID }}
        run: |
          set -euo pipefail
          if [ -z "${MODRINTH_TOKEN:-}" ]; then
            echo "Missing required secret: MODRINTH_TOKEN"
            exit 1
          fi
          if [ -z "${MODRINTH_PROJECT_ID:-}" ]; then
            echo "Missing required secret: MODRINTH_PROJECT_ID"
            exit 1
          fi

      - name: Select release and prepare Modrinth publish matrix
        id: prepare
        env:
          GH_TOKEN: ${{ github.token }}
          MODRINTH_TOKEN: ${{ secrets.MODRINTH_TOKEN }}
          MODRINTH_PROJECT_ID: ${{ secrets.MODRINTH_PROJECT_ID }}
        run: |
          set -euo pipefail

          mkdir -p modrinth-assets

          project_ref="$(printf '%s' "${MODRINTH_PROJECT_ID}" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')"
          if [ -z "${project_ref}" ]; then
            echo "MODRINTH_PROJECT_ID is empty after trimming."
            exit 1
          fi

          project_ref="${project_ref#https://modrinth.com/project/}"
          project_ref="${project_ref#https://modrinth.com/mod/}"
          project_ref="${project_ref#https://modrinth.com/plugin/}"
          project_ref="${project_ref#https://modrinth.com/resourcepack/}"
          project_ref="${project_ref#https://modrinth.com/shader/}"
          project_ref="${project_ref#https://modrinth.com/datapack/}"
          project_ref="${project_ref#http://modrinth.com/project/}"
          project_ref="${project_ref#http://modrinth.com/mod/}"
          project_ref="${project_ref#http://modrinth.com/plugin/}"
          project_ref="${project_ref#http://modrinth.com/resourcepack/}"
          project_ref="${project_ref#http://modrinth.com/shader/}"
          project_ref="${project_ref#http://modrinth.com/datapack/}"
          project_ref="${project_ref%%/*}"
          project_ref="${project_ref%%\?*}"
          project_ref="${project_ref%%#*}"

          if [ -z "${project_ref}" ]; then
            echo "Could not derive Modrinth project ID/slug from MODRINTH_PROJECT_ID."
            exit 1
          fi

          project_ref_encoded="$(jq -rn --arg v "${project_ref}" '$v|@uri')"

          releases_json="$(gh api "repos/${GITHUB_REPOSITORY}/releases?per_page=100")"
          selected_release="$(
            printf '%s' "${releases_json}" \
            | jq -c '[.[] | select(.draft == false and .published_at != null)] | if length == 0 then empty else max_by(.published_at) end'
          )"

          if [ -z "${selected_release}" ]; then
            echo "No published non-draft GitHub release found."
            exit 1
          fi

          selected_tag="$(printf '%s' "${selected_release}" | jq -r '.tag_name')"
          selected_is_prerelease="$(printf '%s' "${selected_release}" | jq -r '.prerelease')"
          release_body="$(printf '%s' "${selected_release}" | jq -r '.body // ""')"

          release_channel="release"
          if [ "${selected_is_prerelease}" = "true" ]; then
            release_channel="beta"
          fi

          mapfile -t jar_asset_rows < <(
            printf '%s' "${selected_release}" \
            | jq -r '.assets[] | select(.name | endswith(".jar")) | [.name, .url] | @tsv'
          )

          if [ "${#jar_asset_rows[@]}" -eq 0 ]; then
            echo "No .jar assets found in selected release ${selected_tag}."
            exit 1
          fi

          for row in "${jar_asset_rows[@]}"; do
            IFS=$'\t' read -r asset_name asset_api_url <<< "${row}"
            gh api \
              -H "Accept: application/octet-stream" \
              "${asset_api_url}" > "modrinth-assets/${asset_name}"
          done

          shopt -s nullglob
          jar_paths=(modrinth-assets/*.jar)
          if [ "${#jar_paths[@]}" -eq 0 ]; then
            echo "No downloaded jar files found."
            exit 1
          fi

          declare -A seen_version_numbers=()
          invalid_names=()
          duplicate_versions=()

          > all_items.jsonl

          for jar_path in "${jar_paths[@]}"; do
            file_name="$(basename "${jar_path}")"

            if [[ "${file_name}" =~ ^nickhider-(fabric|forge|neoforge)-([0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z.-]+)?)\+mc([0-9]+([.][0-9]+){1,2})\.jar$ ]]; then
              loader="${BASH_REMATCH[1]}"
              mod_version="${BASH_REMATCH[2]}"
              mc_version="${BASH_REMATCH[4]}"
              version_number="mc${mc_version}-${mod_version}-${loader}"

              if [ -n "${seen_version_numbers[${version_number}]:-}" ]; then
                duplicate_versions+=("${version_number}")
                continue
              fi
              seen_version_numbers["${version_number}"]=1

              loader_display="Fabric"
              if [ "${loader}" = "forge" ]; then
                loader_display="Forge"
              elif [ "${loader}" = "neoforge" ]; then
                loader_display="NeoForge"
              fi

              version_name="Nick Hider ${mod_version} for ${loader_display} ${mc_version}"

              jq -nc \
                --arg loader "${loader}" \
                --arg mc_version "${mc_version}" \
                --arg mod_version "${mod_version}" \
                --arg version_number "${version_number}" \
                --arg version_name "${version_name}" \
                --arg file_path "${jar_path}" \
                --arg file_name "${file_name}" \
                '{
                  loader: $loader,
                  mc_version: $mc_version,
                  mod_version: $mod_version,
                  version_number: $version_number,
                  version_name: $version_name,
                  file_path: $file_path,
                  file_name: $file_name
                }' >> all_items.jsonl
            else
              invalid_names+=("${file_name}")
            fi
          done

          if [ "${#invalid_names[@]}" -gt 0 ]; then
            echo "Found jar files with invalid names:"
            printf ' - %s\n' "${invalid_names[@]}"
            exit 1
          fi

          if [ "${#duplicate_versions[@]}" -gt 0 ]; then
            echo "Duplicate Modrinth version_number values found:"
            printf ' - %s\n' "${duplicate_versions[@]}"
            exit 1
          fi

          existing_lookup_enabled="true"
          modrinth_versions_http_status="$(
            curl -sS \
              -o modrinth_versions_response.json \
              -w '%{http_code}' \
              -H "Authorization: ${MODRINTH_TOKEN}" \
              -H "User-Agent: github-actions/${GITHUB_REPOSITORY}" \
              "https://api.modrinth.com/v2/project/${project_ref_encoded}/version"
          )"
          if [ "${modrinth_versions_http_status}" = "200" ]; then
            modrinth_versions_json="$(cat modrinth_versions_response.json)"
            printf '%s' "${modrinth_versions_json}" \
              | jq -r '.[].version_number // empty' \
              | sort -u > existing_version_numbers.txt
          elif [ "${modrinth_versions_http_status}" = "404" ] || [ "${modrinth_versions_http_status}" = "403" ]; then
            # Under-review or restricted projects can return 404/403 on read endpoints.
            # In this case we continue without duplicate pre-filtering and rely on publish responses.
            existing_lookup_enabled="false"
            : > existing_version_numbers.txt
            echo "Warning: could not read existing Modrinth versions for '${project_ref}' (HTTP ${modrinth_versions_http_status})."
            echo "Continuing without pre-skip of existing versions."
            cat modrinth_versions_response.json || true
          else
            echo "Failed to fetch Modrinth versions for '${project_ref}'. HTTP ${modrinth_versions_http_status}."
            cat modrinth_versions_response.json || true
            exit 1
          fi

          > publish_items.jsonl
          skipped_existing_count=0
          to_publish_count=0

          while IFS= read -r item; do
            version_number="$(printf '%s' "${item}" | jq -r '.version_number')"
            if grep -Fxq "${version_number}" existing_version_numbers.txt; then
              skipped_existing_count=$((skipped_existing_count + 1))
              continue
            fi
            printf '%s\n' "${item}" >> publish_items.jsonl
            to_publish_count=$((to_publish_count + 1))
          done < all_items.jsonl

          publish_matrix="$(jq -cs '.' publish_items.jsonl)"
          has_work="false"
          if [ "${to_publish_count}" -gt 0 ]; then
            has_work="true"
          fi

          {
            echo "modrinth_project=${project_ref}"
            echo "selected_tag=${selected_tag}"
            echo "selected_is_prerelease=${selected_is_prerelease}"
            echo "release_channel=${release_channel}"
            echo "publish_matrix=${publish_matrix}"
            echo "has_work=${has_work}"
            echo "skipped_existing_count=${skipped_existing_count}"
            echo "to_publish_count=${to_publish_count}"
            echo "total_jar_count=${#jar_paths[@]}"
            echo "existing_lookup_enabled=${existing_lookup_enabled}"
            echo "release_body<<EOF"
            printf '%s\n' "${release_body}"
            echo "EOF"
          } >> "${GITHUB_OUTPUT}"

      - name: Upload selected release jars for publish job
        uses: actions/upload-artifact@v4
        with:
          name: modrinth-source-jars
          if-no-files-found: error
          path: modrinth-assets

  publish:
    needs: prepare
    if: needs.prepare.outputs.has_work == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download selected release jars
        uses: actions/download-artifact@v4
        with:
          name: modrinth-source-jars
          path: .

      - name: Normalize downloaded jar paths
        run: |
          set -euo pipefail
          mkdir -p modrinth-assets

          mapfile -t downloaded_jars < <(find . -type f -name "nickhider-*.jar" | sort -u)
          if [ "${#downloaded_jars[@]}" -eq 0 ]; then
            echo "No jars were downloaded from artifact modrinth-source-jars."
            exit 1
          fi

          for jar in "${downloaded_jars[@]}"; do
            target="modrinth-assets/$(basename "${jar}")"
            if [ "${jar}" != "${target}" ]; then
              cp "${jar}" "${target}"
            fi
          done

      - name: Publish versions to Modrinth (batched, single job)
        env:
          MODRINTH_TOKEN: ${{ secrets.MODRINTH_TOKEN }}
          MODRINTH_PROJECT: ${{ needs.prepare.outputs.modrinth_project }}
          RELEASE_CHANNEL: ${{ needs.prepare.outputs.release_channel }}
          RELEASE_BODY: ${{ needs.prepare.outputs.release_body }}
          PUBLISH_MATRIX: ${{ needs.prepare.outputs.publish_matrix }}
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${PUBLISH_MATRIX}" ] || [ "${PUBLISH_MATRIX}" = "[]" ]; then
            echo "No Modrinth items to publish."
            exit 0
          fi

          total="$(printf '%s' "${PUBLISH_MATRIX}" | jq 'length')"
          if [ "${total}" -eq 0 ]; then
            echo "No Modrinth items to publish."
            exit 0
          fi

          published=0
          failed=0

          while IFS= read -r item; do
            [ -n "${item}" ] || continue

            loader="$(printf '%s' "${item}" | jq -r '.loader')"
            mc_version="$(printf '%s' "${item}" | jq -r '.mc_version')"
            version_number="$(printf '%s' "${item}" | jq -r '.version_number')"
            version_name="$(printf '%s' "${item}" | jq -r '.version_name')"
            file_path="$(printf '%s' "${item}" | jq -r '.file_path')"
            file_name="$(printf '%s' "${item}" | jq -r '.file_name')"

            if [ ! -f "${file_path}" ]; then
              echo "Missing file for ${version_number}: ${file_path}"
              failed=$((failed + 1))
              continue
            fi

            data_json="$(
              jq -nc \
                --arg name "${version_name}" \
                --arg version_number "${version_number}" \
                --arg changelog "${RELEASE_BODY}" \
                --arg game_version "${mc_version}" \
                --arg channel "${RELEASE_CHANNEL}" \
                --arg loader "${loader}" \
                --arg project "${MODRINTH_PROJECT}" \
                --arg file_name "${file_name}" \
                '{
                  name: $name,
                  version_number: $version_number,
                  changelog: $changelog,
                  dependencies: [],
                  game_versions: [$game_version],
                  version_type: $channel,
                  loaders: [$loader],
                  featured: false,
                  status: "listed",
                  project_id: $project,
                  file_parts: [$file_name],
                  primary_file: $file_name
                }'
            )"

            echo "Publishing Modrinth: ${version_number} (${file_name})"
            http_code="$(
              curl -sS \
                -o modrinth_response.json \
                -w '%{http_code}' \
                -X POST "https://api.modrinth.com/v2/version" \
                -H "Authorization: ${MODRINTH_TOKEN}" \
                -H "User-Agent: github-actions/${GITHUB_REPOSITORY}" \
                -F "data=${data_json}" \
                -F "${file_name}=@${file_path};type=application/java-archive"
            )"

            if [ "${http_code}" -ge 200 ] && [ "${http_code}" -lt 300 ]; then
              version_id="$(jq -r '.id // empty' modrinth_response.json)"
              echo "Published Modrinth version ${version_number} (id=${version_id})."
              published=$((published + 1))
            else
              echo "Failed Modrinth publish for ${version_number}. HTTP ${http_code}"
              cat modrinth_response.json || true
              failed=$((failed + 1))
            fi
          done < <(printf '%s' "${PUBLISH_MATRIX}" | jq -c '.[]')

          echo "Modrinth publish result: published=${published} failed=${failed} total=${total}"
          if [ "${failed}" -ne 0 ]; then
            exit 1
          fi

  summary:
    needs: [prepare, publish]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Print publish summary
        run: |
          published_count="0"
          if [ "${{ needs.publish.result }}" = "success" ]; then
            published_count="${{ needs.prepare.outputs.to_publish_count }}"
          elif [ "${{ needs.prepare.outputs.has_work }}" = "true" ]; then
            published_count="unknown (publish job failed)"
          fi

          echo "Selected GitHub release tag: ${{ needs.prepare.outputs.selected_tag }}"
          echo "Resolved Modrinth project: ${{ needs.prepare.outputs.modrinth_project }}"
          echo "Selected release is prerelease: ${{ needs.prepare.outputs.selected_is_prerelease }}"
          echo "Modrinth channel: ${{ needs.prepare.outputs.release_channel }}"
          echo "Existing-version lookup enabled: ${{ needs.prepare.outputs.existing_lookup_enabled }}"
          echo "Total jars discovered: ${{ needs.prepare.outputs.total_jar_count }}"
          echo "Versions skipped as existing: ${{ needs.prepare.outputs.skipped_existing_count }}"
          echo "Versions published: ${published_count}"
          echo "Versions planned to publish: ${{ needs.prepare.outputs.to_publish_count }}"
          echo "Publish job result: ${{ needs.publish.result }}"

          {
            echo "## Manual Modrinth Publish Summary"
            echo
            echo "- Selected GitHub release tag: \`${{ needs.prepare.outputs.selected_tag }}\`"
            echo "- Resolved Modrinth project: \`${{ needs.prepare.outputs.modrinth_project }}\`"
            echo "- Selected release is prerelease: \`${{ needs.prepare.outputs.selected_is_prerelease }}\`"
            echo "- Modrinth channel: \`${{ needs.prepare.outputs.release_channel }}\`"
            echo "- Existing-version lookup enabled: \`${{ needs.prepare.outputs.existing_lookup_enabled }}\`"
            echo "- Total jars discovered: \`${{ needs.prepare.outputs.total_jar_count }}\`"
            echo "- Versions skipped as existing: \`${{ needs.prepare.outputs.skipped_existing_count }}\`"
            echo "- Versions published: \`${published_count}\`"
            echo "- Versions planned to publish: \`${{ needs.prepare.outputs.to_publish_count }}\`"
            echo "- Publish job result: \`${{ needs.publish.result }}\`"
          } >> "${GITHUB_STEP_SUMMARY}"
