name: Manual Curseforge Publish

on:
  workflow_dispatch:
  workflow_call:
    secrets:
      CURSEFORGE_TOKEN:
        required: true
      CURSEFORGE_PROJECT_ID:
        required: true

permissions:
  contents: read

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      selected_tag: ${{ steps.prepare.outputs.selected_tag }}
      selected_is_prerelease: ${{ steps.prepare.outputs.selected_is_prerelease }}
      release_type: ${{ steps.prepare.outputs.release_type }}
      release_body: ${{ steps.prepare.outputs.release_body }}
      publish_matrix: ${{ steps.prepare.outputs.publish_matrix }}
      has_work: ${{ steps.prepare.outputs.has_work }}
      to_publish_count: ${{ steps.prepare.outputs.to_publish_count }}
      total_jar_count: ${{ steps.prepare.outputs.total_jar_count }}
    steps:
      - name: Validate required secrets
        env:
          CURSEFORGE_TOKEN: ${{ secrets.CURSEFORGE_TOKEN }}
          CURSEFORGE_PROJECT_ID: ${{ secrets.CURSEFORGE_PROJECT_ID }}
        run: |
          set -euo pipefail
          if [ -z "${CURSEFORGE_TOKEN:-}" ]; then
            echo "Missing required secret: CURSEFORGE_TOKEN"
            exit 1
          fi
          if [ -z "${CURSEFORGE_PROJECT_ID:-}" ]; then
            echo "Missing required secret: CURSEFORGE_PROJECT_ID"
            exit 1
          fi
          if ! [[ "${CURSEFORGE_PROJECT_ID}" =~ ^[0-9]+$ ]]; then
            echo "CURSEFORGE_PROJECT_ID must be an integer."
            exit 1
          fi

      - name: Select release and prepare CurseForge publish matrix
        id: prepare
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          mkdir -p curseforge-assets

          releases_json="$(gh api "repos/${GITHUB_REPOSITORY}/releases?per_page=100")"
          selected_release="$(
            printf '%s' "${releases_json}" \
            | jq -c '[.[] | select(.draft == false and .published_at != null)] | if length == 0 then empty else max_by(.published_at) end'
          )"

          if [ -z "${selected_release}" ]; then
            echo "No published non-draft GitHub release found."
            exit 1
          fi

          selected_tag="$(printf '%s' "${selected_release}" | jq -r '.tag_name')"
          selected_is_prerelease="$(printf '%s' "${selected_release}" | jq -r '.prerelease')"
          release_body="$(printf '%s' "${selected_release}" | jq -r '.body // ""')"

          release_type="release"
          if [ "${selected_is_prerelease}" = "true" ]; then
            release_type="beta"
          fi

          mapfile -t jar_asset_rows < <(
            printf '%s' "${selected_release}" \
            | jq -r '.assets[] | select(.name | endswith(".jar")) | [.name, .url] | @tsv'
          )

          if [ "${#jar_asset_rows[@]}" -eq 0 ]; then
            echo "No .jar assets found in selected release ${selected_tag}."
            exit 1
          fi

          for row in "${jar_asset_rows[@]}"; do
            IFS=$'\t' read -r asset_name asset_api_url <<< "${row}"
            gh api \
              -H "Accept: application/octet-stream" \
              "${asset_api_url}" > "curseforge-assets/${asset_name}"
          done

          shopt -s nullglob
          jar_paths=(curseforge-assets/*.jar)
          if [ "${#jar_paths[@]}" -eq 0 ]; then
            echo "No downloaded jar files found."
            exit 1
          fi

          invalid_names=()
          duplicate_keys=()
          declare -A seen_keys=()

          > all_items.jsonl

          for jar_path in "${jar_paths[@]}"; do
            file_name="$(basename "${jar_path}")"

            if [[ "${file_name}" =~ ^nickhider-(fabric|forge|neoforge)-([0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z.-]+)?)\+mc([0-9]+([.][0-9]+){1,2})\.jar$ ]]; then
              loader="${BASH_REMATCH[1]}"
              mod_version="${BASH_REMATCH[2]}"
              mc_version="${BASH_REMATCH[4]}"
              key="${mc_version}|${mod_version}|${loader}"

              if [ -n "${seen_keys[${key}]:-}" ]; then
                duplicate_keys+=("${key}")
                continue
              fi
              seen_keys["${key}"]=1

              loader_display="Fabric"
              if [ "${loader}" = "forge" ]; then
                loader_display="Forge"
              elif [ "${loader}" = "neoforge" ]; then
                loader_display="NeoForge"
              fi

              display_name="Nick Hider ${mod_version} for ${loader_display} ${mc_version}"
              mc_family="$(printf '%s' "${mc_version}" | cut -d'.' -f1-2)"
              game_versions="Minecraft ${mc_family}:${mc_version},${loader_display}"

              jq -nc \
                --arg loader "${loader}" \
                --arg mod_version "${mod_version}" \
                --arg mc_version "${mc_version}" \
                --arg display_name "${display_name}" \
                --arg game_versions "${game_versions}" \
                --arg file_path "${jar_path}" \
                --arg file_name "${file_name}" \
                '{
                  loader: $loader,
                  mod_version: $mod_version,
                  mc_version: $mc_version,
                  display_name: $display_name,
                  game_versions: $game_versions,
                  file_path: $file_path,
                  file_name: $file_name
                }' >> all_items.jsonl
            else
              invalid_names+=("${file_name}")
            fi
          done

          if [ "${#invalid_names[@]}" -gt 0 ]; then
            echo "Found jar files with invalid names:"
            printf ' - %s\n' "${invalid_names[@]}"
            exit 1
          fi

          if [ "${#duplicate_keys[@]}" -gt 0 ]; then
            echo "Duplicate (mc_version, mod_version, loader) tuples found:"
            printf ' - %s\n' "${duplicate_keys[@]}"
            exit 1
          fi

          publish_matrix="$(jq -cs '.' all_items.jsonl)"
          to_publish_count="$(jq -s 'length' all_items.jsonl)"
          has_work="false"
          if [ "${to_publish_count}" -gt 0 ]; then
            has_work="true"
          fi

          {
            echo "selected_tag=${selected_tag}"
            echo "selected_is_prerelease=${selected_is_prerelease}"
            echo "release_type=${release_type}"
            echo "publish_matrix=${publish_matrix}"
            echo "has_work=${has_work}"
            echo "to_publish_count=${to_publish_count}"
            echo "total_jar_count=${#jar_paths[@]}"
            echo "release_body<<EOF"
            printf '%s\n' "${release_body}"
            echo "EOF"
          } >> "${GITHUB_OUTPUT}"

      - name: Upload selected release jars for publish job
        uses: actions/upload-artifact@v4
        with:
          name: curseforge-source-jars
          if-no-files-found: error
          path: curseforge-assets

  publish:
    needs: prepare
    if: needs.prepare.outputs.has_work == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download selected release jars
        uses: actions/download-artifact@v4
        with:
          name: curseforge-source-jars
          path: .

      - name: Normalize downloaded jar paths
        run: |
          set -euo pipefail
          mkdir -p curseforge-assets

          mapfile -t downloaded_jars < <(find . -type f -name "nickhider-*.jar" | sort -u)
          if [ "${#downloaded_jars[@]}" -eq 0 ]; then
            echo "No jars were downloaded from artifact curseforge-source-jars."
            exit 1
          fi

          for jar in "${downloaded_jars[@]}"; do
            target="curseforge-assets/$(basename "${jar}")"
            if [ "${jar}" != "${target}" ]; then
              cp "${jar}" "${target}"
            fi
          done

      - name: Publish versions to CurseForge (batched, single job)
        env:
          CURSEFORGE_TOKEN: ${{ secrets.CURSEFORGE_TOKEN }}
          CURSEFORGE_PROJECT_ID: ${{ secrets.CURSEFORGE_PROJECT_ID }}
          RELEASE_TYPE: ${{ needs.prepare.outputs.release_type }}
          RELEASE_BODY: ${{ needs.prepare.outputs.release_body }}
          PUBLISH_MATRIX: ${{ needs.prepare.outputs.publish_matrix }}
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${PUBLISH_MATRIX}" ] || [ "${PUBLISH_MATRIX}" = "[]" ]; then
            echo "No CurseForge items to publish."
            exit 0
          fi

          total="$(printf '%s' "${PUBLISH_MATRIX}" | jq 'length')"
          if [ "${total}" -eq 0 ]; then
            echo "No CurseForge items to publish."
            exit 0
          fi

          versions_json="$(curl -sS -H "X-Api-Token: ${CURSEFORGE_TOKEN}" "https://minecraft.curseforge.com/api/game/versions")"
          types_json="$(curl -sS -H "X-Api-Token: ${CURSEFORGE_TOKEN}" "https://minecraft.curseforge.com/api/game/version-types")"

          resolve_game_versions() {
            local csv="$1"
            local IFS=','
            read -ra tokens <<< "${csv}"
            local ids=()

            for raw in "${tokens[@]}"; do
              token="$(printf '%s' "${raw}" | sed -E 's/^[[:space:]]+//;s/[[:space:]]+$//')"
              [ -n "${token}" ] || continue

              if [[ "${token}" =~ ^[0-9]+$ ]]; then
                ids+=("${token}")
                continue
              fi

              type_hint="blank"
              lookup="${token}"
              if [[ "${token}" == *:* ]]; then
                type_hint="${token%%:*}"
                lookup="${token#*:}"
              fi

              type_id=""
              if [ "${type_hint}" != "blank" ]; then
                if [[ "${type_hint}" =~ ^[0-9]+$ ]]; then
                  type_id="${type_hint}"
                else
                  type_id="$(
                    printf '%s' "${types_json}" \
                      | jq -r --arg v "${type_hint}" '.[] | select(.name == $v or .slug == $v) | .id' \
                      | head -n1
                  )"
                fi
              fi

              mapfile -t matched_ids < <(
                printf '%s' "${versions_json}" \
                  | jq -r --arg v "${lookup}" --arg tid "${type_id}" '
                      .[]
                      | select(.name == $v or .slug == $v)
                      | select($tid == "" or (.gameVersionTypeID|tostring) == $tid)
                      | .id
                    '
              )

              if [ "${#matched_ids[@]}" -eq 0 ]; then
                echo "Could not resolve CurseForge game version token: ${token}" >&2
                return 1
              fi

              for id in "${matched_ids[@]}"; do
                ids+=("${id}")
              done
            done

            printf '%s\n' "${ids[@]}" | awk 'NF' | sort -u | paste -sd ',' -
          }

          published=0
          failed=0

          while IFS= read -r item; do
            [ -n "${item}" ] || continue

            display_name="$(printf '%s' "${item}" | jq -r '.display_name')"
            file_path="$(printf '%s' "${item}" | jq -r '.file_path')"
            game_versions_csv="$(printf '%s' "${item}" | jq -r '.game_versions')"

            if [ ! -f "${file_path}" ]; then
              echo "Missing file for ${display_name}: ${file_path}"
              failed=$((failed + 1))
              continue
            fi

            if ! game_version_ids_csv="$(resolve_game_versions "${game_versions_csv}")"; then
              echo "Failed to resolve game versions for ${display_name}"
              failed=$((failed + 1))
              continue
            fi

            metadata_json="$(
              jq -nc \
                --arg changelog "${RELEASE_BODY}" \
                --arg display_name "${display_name}" \
                --arg release_type "${RELEASE_TYPE}" \
                --argjson game_versions "$(printf '%s' "${game_version_ids_csv}" | jq -R 'split(",") | map(tonumber)')" \
                '{
                  changelog: $changelog,
                  changelogType: "markdown",
                  displayName: $display_name,
                  releaseType: $release_type,
                  gameVersions: $game_versions
                }'
            )"

            echo "Publishing CurseForge: ${display_name} ($(basename "${file_path}"))"
            http_code="$(
              curl -sS \
                -o curseforge_response.json \
                -w '%{http_code}' \
                -X POST "https://minecraft.curseforge.com/api/projects/${CURSEFORGE_PROJECT_ID}/upload-file" \
                -H "X-Api-Token: ${CURSEFORGE_TOKEN}" \
                -F "file=@${file_path};type=application/java-archive" \
                -F "metadata=${metadata_json}"
            )"

            if [ "${http_code}" = "200" ]; then
              file_id="$(jq -r '.id // empty' curseforge_response.json)"
              echo "Published CurseForge file id=${file_id} for ${display_name}."
              published=$((published + 1))
            else
              echo "Failed CurseForge publish for ${display_name}. HTTP ${http_code}"
              cat curseforge_response.json || true
              failed=$((failed + 1))
            fi
          done < <(printf '%s' "${PUBLISH_MATRIX}" | jq -c '.[]')

          echo "CurseForge publish result: published=${published} failed=${failed} total=${total}"
          if [ "${failed}" -ne 0 ]; then
            exit 1
          fi

  summary:
    needs: [prepare, publish]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Print publish summary
        run: |
          published_count="0"
          if [ "${{ needs.publish.result }}" = "success" ]; then
            published_count="${{ needs.prepare.outputs.to_publish_count }}"
          elif [ "${{ needs.prepare.outputs.has_work }}" = "true" ]; then
            published_count="unknown (publish job failed)"
          fi

          echo "Selected GitHub release tag: ${{ needs.prepare.outputs.selected_tag }}"
          echo "Selected release is prerelease: ${{ needs.prepare.outputs.selected_is_prerelease }}"
          echo "CurseForge release type: ${{ needs.prepare.outputs.release_type }}"
          echo "Total jars discovered: ${{ needs.prepare.outputs.total_jar_count }}"
          echo "Versions published: ${published_count}"
          echo "Versions planned to publish: ${{ needs.prepare.outputs.to_publish_count }}"
          echo "Publish job result: ${{ needs.publish.result }}"

          {
            echo "## Manual Curseforge Publish Summary"
            echo
            echo "- Selected GitHub release tag: \`${{ needs.prepare.outputs.selected_tag }}\`"
            echo "- Selected release is prerelease: \`${{ needs.prepare.outputs.selected_is_prerelease }}\`"
            echo "- CurseForge release type: \`${{ needs.prepare.outputs.release_type }}\`"
            echo "- Total jars discovered: \`${{ needs.prepare.outputs.total_jar_count }}\`"
            echo "- Versions published: \`${published_count}\`"
            echo "- Versions planned to publish: \`${{ needs.prepare.outputs.to_publish_count }}\`"
            echo "- Publish job result: \`${{ needs.publish.result }}\`"
          } >> "${GITHUB_STEP_SUMMARY}"
